# Константа розміру таблиці
M = 13

# Список слів
WORDS = ["ЛЮДИНА", "БЕЗ", "ДРУЗІВ", "ЯК", "ДЕРЕВО", "БЕЗ", "КОРІННЯ"]

# Словник позицій букв (для кирилиці)
LETTER_POSITIONS = {
    'А': 1, 'Б': 2, 'В': 3, 'Г': 4, 'Д': 5, 'Е': 6, 'Є': 7, 'Ж': 8, 'З': 9,
    'И': 10, 'І': 11, 'Ї': 12, 'Й': 13, 'К': 14, 'Л': 15, 'М': 16, 'Н': 17,
    'О': 18, 'П': 19, 'Р': 20, 'С': 21, 'Т': 22, 'У': 23, 'Ф': 24, 'Х': 25,
    'Ц': 26, 'Ч': 27, 'Ш': 28, 'Щ': 29, 'Ь': 30, 'Ю': 31, 'Я': 32
}

# ----------------------
# Хеш-функція
# ----------------------
def simple_hash(key: str) -> int:
    """Обчислення хешу: сума позицій букв mod M"""
    total = sum(LETTER_POSITIONS.get(char.upper(), 0) for char in key)
    return total % M

# ----------------------
# Відкрита адресація (linear probing)
# ----------------------
def build_closed_hash_table(words: list, m: int) -> list:
    """Будує хеш-таблицю з відкритою адресацією"""
    table = [None] * m
    for word in words:
        index = simple_hash(word)
        start_index = index  # для перевірки циклу
        while table[index] is not None:
            index = (index + 1) % m  # лінійне зондування
            if index == start_index:
                raise Exception("Таблиця переповнена!")
        table[index] = word
    return table

# ----------------------
# Візуалізація хеш-таблиці
# ----------------------
def display_closed_table(table: list):
    print("\n--- Закрита хеш-таблиця (відкрита адресація) ---")
    for i, word in enumerate(table):
        print(f"Індекс {i:02d}: {word}")

# ----------------------
# Виконання
# ----------------------
closed_table = build_closed_hash_table(WORDS, M)
display_closed_table(closed_table)

